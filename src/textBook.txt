Ключевое слово abstract

Следующее важное понятие, которое необходимо рассмотреть - ключевое слово 

abstract. Иногда бывает удобным описать только заголовок метода, без его тела, и таким 

образом объявить, что такой метод будет существовать в этом классе. Реализацию этого 

метода, то есть его тело, можно описать позже.

Рассмотрим пример. Предположим, необходимо создать набор графических 

элементов, неважно, каких именно. Например, они могут представлять собой 

геометрические фигуры - круг, квадрат, звезда и т.д.; или элементы пользовательского 

интерфейса - кнопки, поля ввода и т.д. Сейчас это не имеет решающего значения. Кроме 

этого, есть специальный контейнер, который занимается их отрисовкой. Понятно, что 

внешний вид каждой компоненты уникален, не похож на других, а значит, 

соответствующий метод (назовем его paint()) будет реализован в разных элементах 

совсем по-разному.

Но в то же время у компонент может быть много общего. Например, любая из них 

занимает некоторую прямоугольную область контейнера. Сложные контуры фигуры 

необходимо вписать в прямоугольник, чтобы можно было анализировать перекрытия, 

проверять, не вылезает ли компонент за размер контейнера и т.д. Каждая может иметь 

цвет, которым ее надо рисовать, может быть видимой или не видимой, и т.д. Очевидно, 

что полезно создать родительский класс для всех компонент, и один раз объявить в нем 

все общие свойства, чтобы каждая компонента лишь наследовала их.

Но как поступить с методом отрисовки? Ведь родительский класс не представляет 

собой какую-либо фигуру, у него нет визуального представления. Можно объявить метод 

paint() в каждой компоненте независимо. Но тогда контейнер должен будет обладать 

сложной функциональностью для анализа того, какая именно компонента сейчас 

обрабатывается, делать приведение типа и только после этого вызывать нужный метод.

Именно здесь удобно объявить абстрактный метод в родительском классе. У него нет 

внешнего вида, но известно, что он есть у каждого наследника. Поэтому заголовок метода 

описывается в родительском классе, тело метода у каждого наследника свое, а контейнер 

может спокойно пользоваться только базовым типом, не делая никаких приведений.

Приведем упрощенный пример:

// Базовая арифметическая операция

abstract class Operation {

public abstract int calculate(int a, int b);

}

// Сложение

class Addition {

public int calculate(int a, int b) {

return a+b;

}

}

// Вычитание

class Subtraction {

public int calculate(int a, int b) {

return a-b;

}

}

class Test {

public static void main(String s[]) {

Operation o1 = new Addition();

Operation o2 = new Subtraction();

o1.calculate(2, 3);

o2.calculate(3, 5);

}

}

Видно, что выполнения операций сложения и вычитания в методе main() 

записываются совершенно одинаковым образом.

Обратите внимание - поскольку абстрактный метод не имеет тела, после описания 

его заголовка ставится точка с запятой. А раз у него нет тела, то к нему нельзя 

обращаться, пока его наследники не опишут реализацию. Это означает, что нельзя 

создавать экземпляры класса, у которого есть абстрактные методы. Такой класс сам 

объявляется абстрактным.

Класс может быть абстрактным и в случае, если у него нет абстрактных методов, но 

должен быть абстрактным, если такие методы есть. Разработчик может указать ключевое 

слово abstract в списке модификаторов класса, если хочет запретить создание 

экземпляров этого класса. Классы-наследники должны реализовать (implements) все 

абстрактные методы (если они есть) своего абстрактного родителя, чтобы их можно было 

объявлять не абстрактными и порождать от них экземпляры.

Конечно, класс не может быть одновременно abstract и final. Это же верно и 

для методов.

Кроме того, абстрактный метод не может быть private, native, static.

Сам класс может без ограничений пользоваться своими абстрактными методами.

abstract class Test {

public abstract int getX();

public abstract int getY();

pulic double getLength() {

return Math.sqrt(getX()*getX()+getY()*getY());

}

}

Это корректно, поскольку метод getLength() может быть вызван только у 

объекта. Объект может быть порожден только от неабстрактного класса, который является 

наследником от Test, и должен был реализовать все абстрактные методы.

По этой же причине можно объявлять переменные типа абстрактный класс. Они 

могут иметь значение null или ссылаться на объект, порожденный от неабстрактного 

наследника этого класса.

Интерфейсы

Концепция абстрактных методов позволяет предложить альтернативу 

множественному наследованию. В Java класс может иметь только одного родителя, 

поскольку при множественном наследовании могут возникать конфликты, которые 

серьезно запутывают объектную модель. Например, если у класса есть два родителя, 

которые имеют одинаковый метод с различной реализацией, то какой из них унаследует 

новый класс? И как будет работать функциональность родительского класса, который 

лишился своего метода?

Все эти проблемы не возникают в случае, если наследуются только абстрактные 

методы от нескольких родителей. Даже если будет унаследовано несколько одинаковых 

методов, все равно у них нет реализации, и можно один раз описать тело метода, которое 

будет использовано при вызове любого из этих методов.

Именно так устроены интерфейсы в Java. От них нельзя порождать объекты, но 

другие классы могут реализовывать их.

5.1. Объявление интерфейсов

Объявление интерфейсов очень похоже на упрощенное объявление классов.

Объявление начинается с заголовка. Сначала указываются модификаторы. 

Интерфейс может быть объявлен как public, и тогда он будет доступен для всеобщего 

использования, либо модификатор доступа может не указываться, в этом случае 

интерфейс доступен только для типов своего пакета. Модификатор abstract для 

интерфейса не требуется, поскольку все интерфейсы являются абстрактными, его можно 

указать, но рекомендуется этого не делать, чтобы не загромождать код.

Далее записывается ключевое слово interface и имя интерфейса. После этого 

может следовать ключевое слово extends и список интерфейсов, от которых будет 

наследоваться объявляемый интерфейс. Родительских типов может быть много, главное, 

чтобы не было повторений, и чтобы отношение наследования не образовывало 

циклической зависимости.

Наследование интерфейсов действительно очень гибкое. Так, если есть два 

интерфейса A и B, причем B наследуется от A, то новый интерфейс C может 

наследоваться от них обоих. Впрочем, понятно, что указание наследования от A является 

избыточным, все элементы этого интерфейса и так будут получены по наследству через 

интерфейс B.

Затем в фигурных скобках записывается тело интерфейса.

public interface Drawble extends Colorable, Resizable {

}

Тело интерфейса состоит из объявления элементов, то есть полей-констант и 

абстрактных методов.

Все поля интерфейса должны быть public final static, поэтому эти 

модификаторы указывать необязательно и даже не желательно, чтобы не загромождать 

код. Поскольку поля объявляются финальными, необходимо их сразу инициализировать.

public interface Directions {

int RIGTH=1;

int LETFT=2;

int UP=3;

int DOWN=4;

}

Все методы интерфейса являются public abstract, и эти модификаторы также 

являются необязательными и нежелательными.

public interface Moveable {

void moveRight();

void moveLeft();

void moveUp();

void moveDown();

}

Как видно, описание интерфейса гораздо проще, чем объявление класса.